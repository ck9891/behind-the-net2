// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id       String  @id @default(cuid())
  email    String  @unique
  username String  @unique
  name     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  image       UserImage?
  password    Password?
  notes       Note[]
  roles       Role[]
  sessions    Session[]
  connections Connection[]
}

model Note {
  id      String @id @default(cuid())
  title   String
  content String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String

  images NoteImage[]

  // non-unique foreign key
  @@index([ownerId])
  // This helps our order by in the user search a LOT
  @@index([ownerId, updatedAt])
}

model NoteImage {
  id          String  @id @default(cuid())
  altText     String?
  contentType String
  blob        Bytes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  note   Note   @relation(fields: [noteId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  noteId String

  // non-unique foreign key
  @@index([noteId])
}

model UserImage {
  id          String  @id @default(cuid())
  altText     String?
  contentType String
  blob        Bytes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @unique
}

model Password {
  hash String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @unique
}

model Session {
  id             String   @id @default(cuid())
  expirationDate DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String

  // non-unique foreign key
  @@index([userId])
}

model Permission {
  id          String @id @default(cuid())
  action      String // e.g. create, read, update, delete
  entity      String // e.g. note, user, etc.
  access      String // e.g. own or any
  description String @default("")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  roles Role[]

  @@unique([action, entity, access])
}

model Role {
  id          String @id @default(cuid())
  name        String @unique
  description String @default("")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users       User[]
  permissions Permission[]
}

model Verification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  /// The type of verification, e.g. "email" or "phone"
  type String

  /// The thing we're trying to verify, e.g. a user's email or phone number
  target String

  /// The secret key used to generate the otp
  secret String

  /// The algorithm used to generate the otp
  algorithm String

  /// The number of digits in the otp
  digits Int

  /// The number of seconds the otp is valid for
  period Int

  /// The valid characters for the otp
  charSet String

  /// When it's safe to delete this verification
  expiresAt DateTime?

  @@unique([target, type])
}

model Connection {
  id           String @id @default(cuid())
  providerName String
  providerId   String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String

  @@unique([providerName, providerId])
}

model Player {
  id       Int     @id @default(autoincrement())
  playerId String
  season   String
  first    String
  last     String
  position String
  shoots   String
  team     String
  jersey   Int
  gp       Int
  goals    Int
  assists  Int
  // shifts   Shift[]
  // events   Event[]
  Shift    Shift[]
}

model Shift {
  id               Int      @id @default(autoincrement())
  detailCode       String
  gameId           String
  teamId           String
  period           Int
  startTime        DateTime
  duration         Int
  endTime          DateTime
  shiftNumber      Int
  typeCode         String
  eventNumber      Int
  eventDescription String
  player           Player   @relation(fields: [playerId], references: [id])
  playerId         Int
}

model Event {
  id                    Int    @id @default(autoincrement())
  yrGm                  String
  eventId               String
  maxRegulationPeriods  Int    @default(3)
  number                Int
  periodType            String @default("REG")
  minutesElapsed        Int
  secondsElapsed        Int
  minutesRemaining      Int
  secondsRemaining      Int
  situationCode         String
  homeTeamDefendingSide String
  typeCode              String
  zero                  String
  sortOrder             Int
  xCoord                Float
  yCoord                Float
  zoneCode              String
  awayScore             Int
  awaySOG               Int
  homeScore             Int
  homeSOG               Int
  eventOwnerTeamId      String
  shotType              String
  playerId              Int
  shootingPlayerId      Int
  blockingPlayerId      Int
  goalieInNetId         Int
  winningPlayerId       Int
  losingPlayerId        Int
  committedByPlayerId   Int
  drawnByPlayerId       Int
  servedByPlayerId      Int
  hittingPlayerId       Int
  hitteePlayerId        Int
  descKey               String
  duration              Int
  reason                String
  secondaryReason       String
  scoringPlayerId       Int
  scoringPlayerTotal    Int
  assist1PlayerId       Int
  assist1PlayerTotal    Int
  assist2PlayerId       Int
  assist2PlayerTotal    Int
  // player                Player @relation(fields: [playerId], references: [id])
}
